#include <iostream>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include "LocalizationUtils.h"
using namespace std;

LocalizationUtils::LocalizationUtils(void)
{
}


LocalizationUtils::~LocalizationUtils(void)
{
}

bool isnan(double var){
	volatile double d = var;
	return (d != d);
}

double LocalizationUtils::Eucl_distance(Coordinate point1, Coordinate point2){
	double distance;
	distance = sqrt(((point1.x - point2.x)*(point1.x - point2.x)) +
		((point1.y - point2.y)*(point1.y - point2.y)));
	return distance;
}

double LocalizationUtils::Angle_Difference(double angle1, double angle2){
	double res = angle1 - angle2;
	if (res > 180){
		return res-360;
	}else if(res < -180){
		return res+360;
	}
	return res;
}

double LocalizationUtils::Find_angle_avg(double angle1, double angle2) {
	if (isnan(angle1) || isnan(angle2))
		return NULL;
	double x = cos(angle1) + cos(angle2);
	double y = sin(angle1) + sin(angle2);
	return atan2(y, x);
}

double LocalizationUtils::Find_angle_bet_points(Coordinate point1, Coordinate point2){
	double dx = point1.x - point2.x;
	double dy = point1.y - point2.y;
	double res = atan2(dx,dy);
	//maybe needs some checks according to the orientation scheme that we are going to use.
}

LocalizationUtils::Coordinate LocalizationUtils::Add_coordinates(Coordinate point1, Coordinate point2) {
	Coordinate res;
	res.x = point1.x + point2.x;
	res.y = point1.y + point2.y;
	return res;
}

LocalizationUtils::Coordinate LocalizationUtils::Get_symmetric(Coordinate point) {
	Coordinate res;
	res.x = -point.x;
	res.y = -point.y;
	return res;
}

LocalizationUtils::Coordinate LocalizationUtils::Find_object_position(Coordinate agent_pos, double angle, double distance) {
	//needs to check if we are going to include vertical angle from the object
	double x = agent_pos.x + distance * cos(angle);
	double y = agent_pos.y + distance * sin(angle);
	Coordinate Det;
	Det.x = x;
	Det.y = y;
	return Det;
}

LocalizationUtils::Coordinate LocalizationUtils::trilateration(double p1_hor_angle, double p1_ver_angle, double p2_hor_angle, double p2_ver_angle, double p1_dis, double p2_dis) {
	double D = sqrt((pow((p1_hor_angle - p2_hor_angle), 2)) + pow((p1_ver_angle - p2_ver_angle), 2));
	double S = (pow(D, 2) + pow(p1_dis, 2) - pow(p2_dis, 2)) / (2 * D);
	double cx = p1_hor_angle + (p2_hor_angle - p1_hor_angle) * S / D;
	double cy = p1_ver_angle + (p2_ver_angle - p1_ver_angle) * S / D;
	double u = sqrt((pow(p1_dis, 2) - pow(S, 2)));
	double x = cx - (p2_ver_angle - p1_ver_angle) * u / D;
	double y = cy + (p2_hor_angle - p1_hor_angle) * u / D;
	if (0){//some check, because we have two points generated by the intesected cycles
		x = cx + (p2_ver_angle - p1_ver_angle) * u / D;
		y = cy - (p2_hor_angle - p1_hor_angle) * u / D;
	}
	Coordinate Det;
	Det.x = x;
	Det.y = y;
	return Det;
}